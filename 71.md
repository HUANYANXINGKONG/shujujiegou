教材71页简答题中的第4题
设有编号为1，2，3，4的4辆车，顺序进入一个栈式结构的站台，试写出这4辆车开出车站的所有可能的顺序（每辆车可能入站，可能不入站，时间也可能不等）。
1,2,3,4
1,2,4,3
1,3,2,4
1,3,4,2
1,4,3,2
2,1,3,4
2,1,4,3
2,3,1,4
2,3,4,1
2,4,3,1
3,2,1,4
3,2,4,1
3,4,2,1
4,3,2,1

教材71页算法设计题中的第7题
假设有两个已排序（递增）的单链表A和B，编写算法将它们合并成一个链表C而不改变其排序性。
typedef struct Node
{
    int data;
    struct Node *next;
} Node;

Node* mergeSortedLists(Node *A, Node *B)
{
    Node *C = NULL;    // 合并后的链表头
    Node *tail = NULL; // 合并后的链表尾
    
    while (A != NULL && B != NULL)
    {
        Node *newNode;
        if (A->data <= B->data)
        {
            newNode = A;
            A = A->next;
        } 
        else
        {
            newNode = B;
            B = B->next;
        }
        
        // 将新节点添加到C的尾部
        if (C == NULL)
        {
            C = tail = newNode;
        }
        else
        {
            tail->next = newNode;
            tail = newNode;
        }
    }
    
    // 将剩余部分连接到C
    if (A != NULL)
    {
        if (tail != NULL) tail->next = A;
        else C = A;
    }
    else
    {
        if (tail != NULL) tail->next = B;
        else C = B;
    }
    
    return C;
}

教材71页算法设计题中的第8题
假设长度大于1的单循环链表中，既无头结点也无头指针，p为指向该链表中某一结点的指针，编写算法删除该结点的前驱结点。
typedef struct Node
{
    int data;
    struct Node *next;
} Node;

void deletePredecessor(Node *p)
{
    if (p == NULL || p->next == p) return; // 空表或只有一个结点
    
    // 找到p的前驱的前驱
    Node *prePre = p;
    while (prePre->next->next != p)
    {
        prePre = prePre->next;
    }
    
    // 删除前驱结点
    Node *toDelete = prePre->next;
    prePre->next = p;
    free(toDelete);
}

教材71页算法设计题中的第9题
已知两个单链表A和B分别表示两个集合，其元素递增排列，编写算法求出A和B的交集C，要求C同样以元素递增的单链表形式存储。
Node* intersection(Node *A, Node *B)
{
    Node *C = NULL;    // 交集链表头
    Node *tail = NULL; // 交集链表尾
    
    while (A != NULL && B != NULL)
    {
        if (A->data == B->data)
        {
            // 创建新节点
            Node *newNode = (Node*)malloc(sizeof(Node));
            newNode->data = A->data;
            newNode->next = NULL;
            
            // 添加到C的尾部
            if (C == NULL)
            {
                C = tail = newNode;
            }
            else
            {
                tail->next = newNode;
                tail = newNode;
            }
            
            A = A->next;
            B = B->next;
        }
        else if (A->data < B->data)
        {
            A = A->next;
        }
        else
        {
            B = B->next;
        }
    }
    
    return C;
}

教材71页算法设计题中的第10题
写一算法，只扫描一次单链表，就能找到链表中的倒数第n个结点。
Node* findNthFromEnd(Node *head, int n)
{
    if (head == NULL || n <= 0) return NULL;
    
    Node *first = head;  // 先行指针
    Node *second = head; // 后行指针
    
    // 先让first向前移动n步
    for (int i = 0; i < n; i++)
    {
        if (first == NULL) return NULL; // 链表长度不足n
        first = first->next;
    }
    
    // 两个指针同时移动，直到first到达末尾
    while (first != NULL)
    {
        first = first->next;
        second = second->next;
    }
    
    return second;
}

教材71页算法设计题中的第11题
设有一个双向链表，每个结点中除有prior、data和next域外，还有一个访问频度freq域，在链表被起用之前，该域的值初始化为零。每当在链表进行一次Locata(L, x)运算后，令值为x的结点中的freq域增1，并调整表中结点的次序，使其按访问频度的非递增序列排列，以便使频繁访问的结点总是靠近表头。试写一个满足上述要求的Locata(L, x)算法。
typedef struct DNode
{
    int data;
    int freq;
    struct DNode *prior;
    struct DNode *next;
} DNode;

DNode* Locata(DNode *L, int x)
{
    if (L == NULL) return NULL;
    
    DNode *p = L;
    DNode *target = NULL;
    
    // 查找值为x的结点
    do {
        if (p->data == x)
        {
            target = p;
            break;
        }
        p = p->next;
    }while (p != L);
    
    if (target == NULL) return NULL; // 未找到
    
    // 频度加1
    target->freq++;
    
    // 调整位置：按频度非递增排列
    DNode *q = target->prior;
    
    // 向前寻找插入位置
    while (q != target && q->freq < target->freq)
    {
        q = q->prior;
    }
    
    // 如果不需要移动，直接返回
    if (q->next == target) return target;
    
    // 从原位置删除target
    target->prior->next = target->next;
    target->next->prior = target->prior;
    
    // 将target插入到q之后
    target->next = q->next;
    target->prior = q;
    q->next->prior = target;
    q->next = target;
    
    // 如果target被移到表头，返回新的表头
    if (target->prior == L->prior)
    { // 循环链表的表头判断
        return target;
    }
    
    return L; // 返回原表头（可能已改变）
}
